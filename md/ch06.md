# 스트림으로 데이터 수집

Collector, collect 등을 통해 다양한 방법으로 스트림의 최종연산 방법을 처리할 수 있다.

```java
Map<Currency, List<Transaction>> transactionByCurrencies = new HashMap<>();

for (Transaction transaction : transactions ) {
    Currency currency = transaction.getCurrency();
    List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);
    
    if(transactionsForCurrency == null) {
        transactionsForCurrency = new ArrayList<>();
        transactionsByCurrencies.put(currency, transactionsForCurrency);
    }
    
    transactionsForCurrency.add(transaction);
}
```

위와 같은 코드는 심심치 않게 보았을 것이다. 이를 collect를 사용하면 다음과 같이 간결하게 표현할 수 있다.

```java
Map<Currency, List<Transaction>> transactionByCurrencies = 
        transactions.stream().collect(groupingBy(Transaction::getCurrency));
```

## 6.1 컬렉터란 무엇인가?

함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없다. 
Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.

### 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터

collect에서는 내부적으로 **리듀싱 연산**이 일어나고 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리하도록 한다.

이전 트랜잭션 그룹화 예제를 설명하자면, 변환 함수는 각 트랜잭션에서 currency를 추출한 다음에 currency를 키로 사용해서 트랜잭션 자체를 result map에 누적했다.

### 6.1.2 미리 정의된 컬렉션

Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.

- 스트림 요소를 하나의 값으로 리듀스하고 요약
- 요소 그룹화
- 요소 분할

Collectors에서 정의하고 있는 팩토리 메서드는 모두 컬렉터를 반환한다.

각각에 대해 살펴보도록 하자.

## 6.2 리듀싱과 요약

### 6.2.1 스트림값에서 최댓값과 최솟값 검색

### 6.2.2 요약 연산

### 6.2.3 문자열 연결

### 6.2.4 범용 리듀싱 요약 연산

## 6.3 그룹화

### 6.3.1 그룹화된 요소 조작

### 6.3.2 다수준 그룹화

### 6.3.3 서브그룹으로 데이터 수집

## 6.4 분할

### 6.4.1 분할의 장점

### 6.4.2 숫자를 소수와 비소수로 분할하기

## 6.5 인터페이스

### 6.5.1 Collector 인터페이스의 메서드 살펴보기

### 6.5.2 응용하기

## 6.6 커스텀 컬렉터를 구현해서 성능 개선하기

### 6.6.1 소수로만 나누기

### 6.6.2 컬렉터 성능 비교

## 6.7 마치며


[Java 8 Docs](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html)



